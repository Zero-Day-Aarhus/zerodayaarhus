<!-- Ja det skal nok blive fikset til noget bedre. fx. med static site generator. Men det må lige blive en anden dag -->
<html>
  <head>
    <title>0-day Aarhus</title>
    <meta
      name="description"
      content="0-day Aarhus - lokal hackerforening i Aarhus"
    />
    <style>
      body {
        font-family: Andale Mono, monospace;
      }
      ul {
        list-style-type: none;
        margin: 0;
        padding: 0;
        overflow: hidden;
      }

      li a {
        text-decoration: none;
      }
      li {
        font-family: Andale Mono, monospace;
        display: inline;
      }
    </style>
  </head>
  <body text="#00b000" bgcolor="#000000" vlink="#00ff00" link="#00ff00">
    <div style="max-width: 885px; margin-left: auto; margin-right: auto">
      <center>
        <ul>
          <li><a href="/">Root</a></li>
          <li><a href="/key.pub">Public_key</a></li>
          <li><a href="/writeups.html">Writeups</a></li>
        </ul>
        <br />
      </center>
      <center> <h1 id="nc3-writeup">2022 NC3 Writeup</h1> </center>
<h2 id="juledonation">Juledonation</h2>
<pre><code><span class="hljs-built_in">file</span> wallet
</code></pre><p>Giver</p>
<pre><code>wallet  ASCII <span class="hljs-keyword">text</span>, <span class="hljs-keyword">with</span> very <span class="hljs-keyword">long</span> <span class="hljs-keyword">lines</span> (<span class="hljs-number">3656</span>), <span class="hljs-keyword">with</span> no <span class="hljs-built_in">line</span> terminators
</code></pre><p>Hvilket ikke er super brugbart. Men efter at google de første seks karakterer af filen, ser det ud at filen er en Electrum wallet. Efter at downloade og åbne filen med Electrum, viser det sig desværre filen er krypteret og kræver et kodeord for at blive dekrypteret.
Heldigvis findes der et script btcrecover <a href="https://github.com/gurnec/btcrecover">https://github.com/gurnec/btcrecover</a> som kan lave en dictionary password attack, på mange forskellige cryptocurrencies wallet formats, heriblandt Electrum. Password filen rockyou.txt plejer at være det første man forsøger til en typisk CTF opgave med password bruteforce</p>
<p><img src="/wallet_1.png" alt="Alt text"></p>
<pre><code><span class="hljs-comment">python3</span> <span class="hljs-comment">btcrecover</span><span class="hljs-string">.</span><span class="hljs-comment">py</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">wallet</span> <span class="hljs-comment">wallet</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">passwordlist</span> <span class="hljs-comment">rockyou</span><span class="hljs-string">.</span><span class="hljs-comment">txt</span>
</code></pre><p>Giver</p>
<pre><code>Password <span class="hljs-string">found:</span> <span class="hljs-string">'julemanden007'</span>
</code></pre><p><img src="/wallet_2.png" alt="Alt text"></p>
<p>Efter at indtaste kodeordet i Electrum, får jeg endelig adgang til min bitcoin adresse dog med en saldo på 0 bitcoins. I stedet får jeg et flag som ses fanen Receive.</p>
<h2 id="et-nul">et-nul</h2>
<pre><code><span class="hljs-number">0110000110011111100011111110000111101111111101111111100000000011000011011000001101100000000000000011111111011110110000000000000001100001101111001111110001111110011111111011000011011110111100011100011011000011011000001100110000110000000000110000000000001110001101100000110110000000000000000001100000110011000000000000000111000110011001100001101100001101100000001110001101111000011001111001101100000000000000110011000011000000000011000000000000111100110110000011011000000000000000000110000011001100000000000000011110011001100110000000110000000110000000111100110111100001100110110110110000000011111110011100001111110000001100000000000011011011011000001101100000000000000000011000001100110000000000000001101101100110001111110001111110011111100011011011001100000111011001111011000000000000001100110000110000000000110000000000001100111101100000110110000000000000000001100000110011000000000000000110011110011000000001100000001101100000001100111100000000011001100011101100001101100000110011000011000000000011000000000000110001110110000011011000000000000000000110000011001100000000000000011000111001100110000110110000110110000000110001110111100001100110000110011111100011111110000111101111111100001100001111111011000011001111111001111111101111111000011000011110111111110111111101100001101111001111110001111110011111111011000011011110111100</span>
</code></pre><p>Den første tanke var at prøve at konventere filen til binary, men der kom ikke rigtig noget frem med det. Måske det slet ikke var noget filformat. Et filformat vi typisk aldrig have så mange nummer efterfulgt af hinanden, pga. unødvendig redundans. 
Rigtig mange steder i filen havde præcist 18 nuller (&quot;000000000000000000&quot;), måske det var ASCII ART. Efter er lave et hurtigt Python script, og med lidt trial and error kom flaget frem:</p>
<pre><code>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">'et-nul'</span>, <span class="hljs-string">'r'</span>).<span class="hljs-built_in">read</span>().<span class="hljs-built_in">replace</span>(<span class="hljs-string">'1'</span>, <span class="hljs-string">'■'</span>).<span class="hljs-built_in">replace</span>(<span class="hljs-string">'0'</span>, <span class="hljs-string">'.'</span>)


def formatter(lineLength):
    print(<span class="hljs-string">"lineLength = {0}"</span>.<span class="hljs-built_in">format</span>(lineLength))
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">len</span>(f)):
        k = f[i]


        <span class="hljs-keyword">if</span> i % lineLength == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> i != <span class="hljs-number">0</span>:
            print()

        print(k,<span class="hljs-keyword">end</span>=<span class="hljs-string">''</span>)
    print(<span class="hljs-string">"\n"</span>*<span class="hljs-number">3</span>)

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>, <span class="hljs-number">400</span>):
    formatter(i)
</code></pre><p><img src="/et-nul.png" alt="Alt text"></p>
<h2 id="banke-p-">Banke på</h2>
<p>Vi er givet et ELF (executable) binary, som tager en streng, og krypterer hver enkelt karakter til et tal mellem 0 og 65535. Dette tal er Dst port i et UDP PACKET, som bliver sendt til 127.0.0.1. Opgaven giver os en PCAPNG fil, som dermed er den kryptede tekst der skal dekrypteres. I stedet for at reverse krypterings-algoritmen, kan man bare brute force en karakter ad gangen, indtil det passer med PCAPNG filen. Dette kan kun gøres fordi det er en stream cipher, det vil sige hver enkelt karakter er krypteret uafhængigt af hinanden. </p>
<pre><code><span class="hljs-keyword">import</span> subprocess
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">from</span> pcapng <span class="hljs-keyword">import</span> <span class="hljs-type">FileScanner</span>

packets = []
<span class="hljs-keyword">with</span> open('banke-paa.pcapng', 'rb') <span class="hljs-keyword">as</span> fp:
    scanner = <span class="hljs-type">FileScanner</span>(fp)
    <span class="hljs-keyword">for</span> <span class="hljs-keyword">block</span> <span class="hljs-keyword">in</span> scanner:
        packets.append(<span class="hljs-keyword">block</span>)        
packets = packets[<span class="hljs-number">3</span>:]

<span class="hljs-type">UDP_packets</span> = []
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len(packets) // <span class="hljs-number">2</span>):
    <span class="hljs-keyword">block</span> = packets[i*<span class="hljs-number">2</span>]
    a = <span class="hljs-keyword">block</span>.packet_data[-<span class="hljs-number">17</span>] <span class="hljs-comment"># bedste UDP parser ever</span>
    b = <span class="hljs-keyword">block</span>.packet_data[-<span class="hljs-number">18</span>]
    <span class="hljs-type">UDP_packets</span>.append(a  + b * <span class="hljs-number">256</span>)

flag = <span class="hljs-string">""</span>

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len(<span class="hljs-type">UDP_packets</span>)):
    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>, <span class="hljs-number">128</span>):
        flag_candidate = flag + chr(k)
        encrypted_char = <span class="hljs-built_in">int</span>(subprocess.run([<span class="hljs-string">"./banke-paa"</span>, flag_candidate, <span class="hljs-string">"127.0.0.1"</span>], capture_output=<span class="hljs-type">True</span>).<span class="hljs-literal">stdout</span>.decode(<span class="hljs-string">"utf-8"</span>).split('\n')[-<span class="hljs-number">2</span>].split(':')[<span class="hljs-number">1</span>].strip())
        <span class="hljs-keyword">if</span> encrypted_char == <span class="hljs-type">UDP_packets</span>[i]:
            temp = flag_candidate
            <span class="hljs-keyword">continue</span>

    flag = temp
    print(flag)
</code></pre><p>Giver:</p>
<pre><code>n
nc
.
.
.
nc3{<span class="hljs-keyword">julemanden </span><span class="hljs-keyword">banker </span>aldrig paa
nc3{<span class="hljs-keyword">julemanden </span><span class="hljs-keyword">banker </span>aldrig paa!
nc3{<span class="hljs-keyword">julemanden </span><span class="hljs-keyword">banker </span>aldrig paa!}
</code></pre>

    </div>
  </body>
</html>
